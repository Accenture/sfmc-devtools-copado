{
  "recordTypeMap": {},
  "RecordSetBundles": [
    {
      "Records": [
        {
          "attributes": {
            "type": "copado__JobTemplate__c",
            "url": "/services/data/v54.0/sobjects/copado__JobTemplate__c/a2009000000UHDfAAO"
          },
          "copado__ApiName__c": "MC_Promote_Action_1",
          "copado__Type__c": "Custom",
          "copado__Version__c": 1,
          "CreatedDate": "2021-10-11T09:23:03.000+0000",
          "Id": "a2009000000UHDfAAO",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T09:02:15.000+0000",
          "LastReferencedDate": "2022-02-03T15:23:37.000+0000",
          "LastViewedDate": "2022-02-03T15:23:37.000+0000",
          "Name": "MC Promote Action",
          "SystemModstamp": "2022-01-12T09:02:15.000+0000"
        },
        {
          "attributes": {
            "type": "copado__JobTemplate__c",
            "url": "/services/data/v54.0/sobjects/copado__JobTemplate__c/a2009000000UHDkAAO"
          },
          "copado__ApiName__c": "MC_Deploy_Action_1",
          "copado__Type__c": "Custom",
          "copado__Version__c": 1,
          "CreatedDate": "2021-10-11T09:26:09.000+0000",
          "Id": "a2009000000UHDkAAO",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T09:02:15.000+0000",
          "LastReferencedDate": "2022-02-23T08:16:04.000+0000",
          "LastViewedDate": "2022-02-23T08:16:04.000+0000",
          "Name": "MC Deploy Action",
          "SystemModstamp": "2022-01-12T09:02:15.000+0000"
        },
        {
          "attributes": {
            "type": "copado__JobTemplate__c",
            "url": "/services/data/v54.0/sobjects/copado__JobTemplate__c/a2009000000UHDpAAO"
          },
          "copado__ApiName__c": "MC_Commit_Action_1",
          "copado__Type__c": "Custom",
          "copado__Version__c": 1,
          "CreatedDate": "2021-10-11T09:32:34.000+0000",
          "Id": "a2009000000UHDpAAO",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T09:02:15.000+0000",
          "LastReferencedDate": "2022-02-03T10:18:42.000+0000",
          "LastViewedDate": "2022-02-03T10:18:42.000+0000",
          "Name": "MC Commit Action",
          "SystemModstamp": "2022-01-12T09:02:15.000+0000"
        },
        {
          "attributes": {
            "type": "copado__JobTemplate__c",
            "url": "/services/data/v54.0/sobjects/copado__JobTemplate__c/a2009000000UJ7VAAW"
          },
          "copado__ApiName__c": "MC_Snapshot_Action_1",
          "copado__Type__c": "Custom",
          "copado__Version__c": 1,
          "CreatedDate": "2021-11-11T08:59:43.000+0000",
          "Id": "a2009000000UJ7VAAW",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T09:01:33.000+0000",
          "LastReferencedDate": "2022-01-12T09:01:35.000+0000",
          "LastViewedDate": "2022-01-12T09:01:35.000+0000",
          "Name": "MC Snapshot Action",
          "SystemModstamp": "2022-01-12T09:01:33.000+0000"
        },
        {
          "attributes": {
            "type": "copado__JobTemplate__c",
            "url": "/services/data/v54.0/sobjects/copado__JobTemplate__c/a2009000000WQojAAG"
          },
          "copado__ApiName__c": "MC_Retrieve_Action_1",
          "copado__Type__c": "Custom",
          "copado__Version__c": 1,
          "CreatedDate": "2022-01-11T11:01:43.000+0000",
          "Id": "a2009000000WQojAAG",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T09:02:15.000+0000",
          "LastReferencedDate": "2022-01-12T09:02:15.000+0000",
          "LastViewedDate": "2022-01-12T09:02:15.000+0000",
          "Name": "MC Retrieve Action",
          "SystemModstamp": "2022-01-12T09:02:15.000+0000"
        }
      ],
      "ObjectType": "copado__JobTemplate__c"
    },
    {
      "Records": [
        {
          "attributes": {
            "type": "copado__JobStep__c",
            "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a1z09000000XqX5AAK"
          },
          "copado__ApiName__c": "Marketing Cloud Promote_MC Promote Function",
          "copado__ConfigJson__c": "{\"functionName\":\"MC_Promote\",\"parameters\":[{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"user_stories\",\"value\":\"{$Context.JobExecution__r.DataJson.userStoryBranches}\",\"required\":true},{\"name\":\"promotion\",\"value\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\",\"required\":true},{\"name\":\"target_branch\",\"value\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\",\"required\":true},{\"name\":\"tag\",\"value\":\"\",\"required\":false},{\"name\":\"merge_strategy\",\"value\":\"theirs\",\"required\":true}]}",
          "copado__CustomType__c": "Function",
          "copado__JobTemplate__c": "a2009000000UHDfAAO",
          "copado__Order__c": 1,
          "copado__Type__c": "Function",
          "CreatedDate": "2021-10-11T09:24:40.000+0000",
          "Id": "a1z09000000XqX5AAK",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T08:37:23.000+0000",
          "Name": "MC Promote Step",
          "SystemModstamp": "2022-01-12T08:37:23.000+0000"
        },
        {
          "attributes": {
            "type": "copado__JobStep__c",
            "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a1z09000000XqXAAA0"
          },
          "copado__ApiName__c": "MC Deploy Action_MC Deploy Function",
          "copado__ConfigJson__c": "{\"functionName\":\"MC_Deploy\",\"parameters\":[{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true},{\"name\":\"mcdev_version\",\"value\":\"{$Pipeline.Property.mc_devtools_version}\",\"required\":true},{\"name\":\"promotion\",\"value\":\"{$Context.JobExecution__r.Deployment__r.Promotion__r.Name}\",\"required\":true},{\"name\":\"credentialName\",\"value\":\"{$Pipeline.Property.mc_credential_name}\",\"required\":true},{\"name\":\"clientId\",\"value\":\"{$Pipeline.Property.mc_client_id}\",\"required\":true},{\"name\":\"clientSecret\",\"value\":\"{$Pipeline.Property.mc_client_secret}\",\"required\":true},{\"name\":\"tenant\",\"value\":\"{$Pipeline.Property.mc_tenant}\",\"required\":true},{\"name\":\"toBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\",\"required\":false},{\"name\":\"promotionBranch\",\"value\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\"},{\"name\":\"merge_strategy\",\"value\":\"theirs\"}]}",
          "copado__CustomType__c": "Function",
          "copado__JobTemplate__c": "a2009000000UHDkAAO",
          "copado__Order__c": 1,
          "copado__Type__c": "Function",
          "CreatedDate": "2021-10-11T09:28:06.000+0000",
          "Id": "a1z09000000XqXAAA0",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T08:38:51.000+0000",
          "Name": "MC Deploy Step",
          "SystemModstamp": "2022-01-12T08:38:51.000+0000"
        },
        {
          "attributes": {
            "type": "copado__JobStep__c",
            "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a1z09000000XqXFAA0"
          },
          "copado__ApiName__c": "MC Commit Action_MC Commit Function",
          "copado__ConfigJson__c": "{\"functionName\":\"MC_Commit\",\"parameters\":[{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":false},{\"name\":\"feature_branch\",\"value\":\"{$Context.JobExecution__r.DataJson.featureBranchName}\",\"required\":false},{\"name\":\"main_branch\",\"value\":\"{$Context.JobExecution__r.DataJson.baseBranch}\",\"required\":false},{\"name\":\"mcdev_version\",\"value\":\"{$Pipeline.Property.mc_devtools_version}\"},{\"name\":\"credentialName\",\"value\":\"{$Pipeline.Property.mc_credential_name}\"},{\"name\":\"clientId\",\"value\":\"{$Pipeline.Property.mc_client_id}\"},{\"name\":\"clientSecret\",\"value\":\"{$Pipeline.Property.mc_client_secret}\"},{\"name\":\"tenant\",\"value\":\"{$Pipeline.Property.mc_tenant}\"},{\"name\":\"commit_message\",\"value\":\"{$Context.JobExecution__r.DataJson.message}\"},{\"name\":\"metadata_file\",\"value\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"}]}",
          "copado__CustomType__c": "Function",
          "copado__JobTemplate__c": "a2009000000UHDpAAO",
          "copado__Order__c": 1,
          "copado__Type__c": "Function",
          "CreatedDate": "2021-10-12T09:24:06.000+0000",
          "Id": "a1z09000000XqXFAA0",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T08:37:16.000+0000",
          "Name": "MC Commit Step",
          "SystemModstamp": "2022-01-12T08:37:16.000+0000"
        },
        {
          "attributes": {
            "type": "copado__JobStep__c",
            "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a1z09000000Xqf7AAC"
          },
          "copado__ApiName__c": "Marketing Cloud Snapshot_MC Snapshot",
          "copado__ConfigJson__c": "{\"functionName\":\"MC_Commit\",\"parameters\":[{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":false},{\"name\":\"feature_branch\",\"value\":\"\",\"required\":false},{\"name\":\"main_branch\",\"value\":\"master\",\"required\":false},{\"name\":\"mcdev_version\",\"value\":\"{$Pipeline.Property.mc_devtools_version}\"},{\"name\":\"credentialName\",\"value\":\"{$Pipeline.Property.mc_credential_name}\"},{\"name\":\"clientId\",\"value\":\"{$Pipeline.Property.mc_client_id}\"},{\"name\":\"clientSecret\",\"value\":\"{$Pipeline.Property.mc_client_secret}\"},{\"name\":\"tenant\",\"value\":\"{$Pipeline.Property.mc_tenant}\"},{\"name\":\"commit_message\",\"value\":\"Marketing Cloud snapshot\"},{\"name\":\"metadata_file\",\"value\":\"\"}]}",
          "copado__CustomType__c": "Function",
          "copado__JobTemplate__c": "a2009000000UJ7VAAW",
          "copado__Order__c": 1,
          "copado__Type__c": "Function",
          "CreatedDate": "2021-11-25T08:33:32.000+0000",
          "Id": "a1z09000000Xqf7AAC",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T08:37:28.000+0000",
          "Name": "MC Snapshot Step",
          "SystemModstamp": "2022-01-12T08:37:28.000+0000"
        },
        {
          "attributes": {
            "type": "copado__JobStep__c",
            "url": "/services/data/v54.0/sobjects/copado__JobStep__c/a1z09000000XqiaAAC"
          },
          "copado__ApiName__c": "MC Retrieve Action_MC Retrieve",
          "copado__ConfigJson__c": "{\"functionName\":\"MC_Retrieve\",\"parameters\":[{\"name\":\"envId\",\"value\":\"{$Source.Id}\",\"required\":false},{\"name\":\"main_branch\",\"value\":\"master\"},{\"name\":\"mcdev_version\",\"value\":\"{$Pipeline.Property.mc_devtools_version}\"},{\"name\":\"credentialName\",\"value\":\"{$Pipeline.Property.mc_credential_name}\"},{\"name\":\"clientId\",\"value\":\"{$Pipeline.Property.mc_client_id}\"},{\"name\":\"clientSecret\",\"value\":\"{$Pipeline.Property.mc_client_secret}\"},{\"name\":\"tenant\",\"value\":\"{$Pipeline.Property.mc_tenant}\"},{\"name\":\"git_json\",\"value\":\"{$Context.Repository.Credential}\",\"required\":true}]}",
          "copado__CustomType__c": "Function",
          "copado__JobTemplate__c": "a2009000000WQojAAG",
          "copado__Order__c": 1,
          "copado__Type__c": "Function",
          "CreatedDate": "2022-01-11T11:03:09.000+0000",
          "Id": "a1z09000000XqiaAAC",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-12T08:37:33.000+0000",
          "Name": "MC Retrieve Step",
          "SystemModstamp": "2022-01-12T08:37:33.000+0000"
        }
      ],
      "ObjectType": "copado__JobStep__c"
    },
    {
      "Records": [
        {
          "attributes": {
            "type": "copado__Function__c",
            "url": "/services/data/v54.0/sobjects/copado__Function__c/a1t09000000YGtPAAW"
          },
          "copado__API_Name__c": "MC_Deploy",
          "copado__Description__c": "Deploy Marketing Cloud changes\r\nWhen executing this function as a test, a context Id is required. To get the value, go to a job step linked to a MC promotion job template, and copy the record Id from the URL.",
          "copado__Image_Name__c": "us.gcr.io/copado-backend-functions-prod/copado-multicloud-dpl:v1",
          "copado__Options__c": "[ ]",
          "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"mcdev_version\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_devtools_version}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"promotion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.Deployment__r.Promotion__r.Name}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"credentialName\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_credential_name}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"clientId\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_client_id}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"clientSecret\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_client_secret}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"tenant\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_tenant}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"toBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJSON.destinationBranchName}\"\n}, {\n  \"name\" : \"promotionBranch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJSON.promotionBranchName}\"\n}, {\n  \"name\" : \"merge_strategy\",\n  \"defaultValue\" : \"theirs\"\n} ]",
          "copado__Script__c": "#!/usr/bin/env node\n\nconst fs = require('fs');\nconst execSync = require('child_process').execSync;\n\nconst CONFIG = {\n    // generic\n    clientId: process.env.clientId,\n    clientSecret: process.env.clientSecret,\n    configFilePath: '/tmp/.mcdevrc.json',\n    credentialName: process.env.credentialName,\n    debug: true,\n    envId: null,\n    mainBranch: null,\n    mcdev: 'node ./node_modules/mcdev/lib/index.js',\n    mcdevVersion: process.env.mcdev_version,\n    metadataFilePath: null,\n    tenant: process.env.tenant,\n    // commit\n    commitMessage: null,\n    featureBranch: null,\n    metadataFile: null,\n    metadataFileName: null,\n    // deploy\n    deltaPackageLog: '/tmp/docs/deltaPackage/delta_package.md',\n    fromCommit: 'promotion/' + process.env.promotion, // The source branch of a PR, typically something like 'feature/...'\n    git_depth: 100, // set a default git depth of 100 commits\n    merge_strategy: process.env.merge_strategy, // set default merge strategy\n    promotionBranch: process.env.promotionBranch, // The promotion branch of a PR\n    toBranch: process.env.toBranch, // The target branch of a PR, like master. This commit will be lastly checked out\n};\n\n/**\n * logger class\n */\nclass Log {\n    /**\n     * constructor\n     */\n    constructor() {}\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static debug(msg) {\n        if (true == CONFIG.debug) {\n            console.log(msg);\n        }\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static warn(msg) {\n        console.log(msg);\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static info(msg) {\n        console.log(msg);\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static error(msg) {\n        Log.warn(msg);\n        execSync(\"copado --error-message '\" + msg + \"'\");\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static progress(msg) {\n        Log.debug(msg);\n        execSync(\"copado --progress '\" + msg + \"'\");\n    }\n}\n\n/**\n * helper class\n */\nclass Util {\n    /**\n     * Execute command\n     * @param {string} [preMsg] the message displayed to the user in copado before execution\n     * @param {string} command the cli command to execute synchronously\n     * @param {string} [postMsg] the message displayed to the user in copado after execution\n     * @returns {void}\n     */\n    static execCommand(preMsg, command, postMsg) {\n        if (null != preMsg) {\n            Log.progress(preMsg);\n        }\n        Log.debug(command);\n\n        try {\n            execSync(command, { stdio: 'inherit', stderr: 'inherit' });\n        } catch (error) {\n            Log.error(error.status + ': ' + error.message);\n            throw new Error(error);\n        }\n\n        if (null != postMsg) {\n            Log.progress(postMsg);\n        }\n    }\n\n    /**\n     * Execute command but return the exit code\n     * @param {string} [preMsg] the message displayed to the user in copado before execution\n     * @param {string} command the cli command to execute synchronously\n     * @param {string} [postMsg] the message displayed to the user in copado after execution\n     * @return {number} exit code\n     */\n    static execCommandReturnStatus(preMsg, command, postMsg) {\n        if (null != preMsg) {\n            Log.progress(preMsg);\n        }\n        Log.debug(command);\n\n        let exitCode = null;\n        try {\n            execSync(command, { stdio: 'inherit', stderr: 'inherit' });\n\n            // Seems command finished successfully, so change exit code from null to 0\n            exitCode = 0;\n        } catch (error) {\n            Log.warn(error.status + ': ' + error.message);\n\n            // The command failed, take the exit code from the error\n            exitCode = error.status;\n        }\n\n        if (null != postMsg) {\n            Log.progress(postMsg);\n        }\n\n        return exitCode;\n    }\n\n    /**\n     * Installs MC Dev Tools and prints the version number\n     * TODO: This will later be moved into an according Docker container.\n     * @returns {void}\n     */\n    static provideMCDevTools() {\n        Util.execCommand(\n            'Initializing npm',\n            'cd /tmp && npm init -y',\n            'Completed initializing NPM'\n        );\n\n        Util.execCommand(\n            'Initializing MC Dev Tools version ' + CONFIG.mcdevVersion,\n            'cd /tmp && npm install --save mcdev@' +\n                CONFIG.mcdevVersion +\n                ' --foreground-scripts && ' +\n                CONFIG.mcdev +\n                ' --version',\n            'Completed installing MC Dev Tools'\n        );\n    }\n\n    /**\n     * Initializes MC project\n     * @returns {void}\n     */\n    static initProject() {\n        // ! UPDATE NEEDED\n        // TODO make eid configurable!!!\n        const authJson = `{\n            \"credentials\": {\n                \"${CONFIG.credentialName}\": {\n                    \"clientId\": \"${CONFIG.clientId}\",\n                    \"clientSecret\": \"${CONFIG.clientSecret}\",\n                    \"tenant\": \"${CONFIG.tenant}\",\n                    \"eid\": \"7281698\"\n                }\n            }\n        }`;\n        Log.progress('Provide authentication');\n        fs.writeFileSync('/tmp/.mcdev-auth.json', authJson);\n        Log.progress('Completed providing authentication');\n        // The following command fails for an unknown reason.\n        // As workaround, provide directly the authentication file. This is also faster.\n        // Util.execCommand(\"Initializing MC project with credential name \" + credentialName + \" for tenant \" + tenant,\n        //            \"cd /tmp && \" + mcdev + \" init --y.credentialsName \" + credentialName + \" --y.clientId \" + clientId + \" --y.clientSecret \" + clientSecret + \" --y.tenant \" + tenant + \" --y.gitRemoteUrl \" + remoteUrl,\n        //            \"Completed initializing MC project\");\n    }\n}\n\n/**\n * handles downloading metadata\n */\nclass Deploy {\n    /**\n     * Determines the deploy folder from MC Dev configuration (.mcdev.json)\n     * @returns {string} deploy folder\n     */\n    static getDeployFolder() {\n        if (!fs.existsSync(CONFIG.configFilePath)) {\n            throw new Error('Could not find config file ' + CONFIG.configFilePath);\n        }\n        const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, 'utf8'));\n        const directories = config['directories'];\n        if (null == directories) {\n            throw new Error('Could not find directories in ' + CONFIG.configFilePath);\n        }\n        const folder = directories['deploy'];\n        if (null == folder) {\n            throw new Error('Could not find directories/deploy in ' + CONFIG.configFilePath);\n        }\n\n        Log.debug('Deploy folder is: ' + folder);\n        return folder;\n    }\n\n    /**\n     * Create the delta package containing the changed components\n     * return whether the delta package is empty or not\n     * @param {string} deployFolder path\n     * @returns {boolean} true: files found, false: not\n     */\n    static createDeltaPackage(deployFolder) {\n        const versionRange = 'HEAD^..HEAD';\n        Util.execCommand(\n            'Create delta package using version range ' + versionRange,\n            'cd /tmp && ' + CONFIG.mcdev + ' createDeltaPkg ' + versionRange + ' --skipInteraction',\n            'Completed creating delta package'\n        );\n        if (fs.existsSync(CONFIG.deltaPackageLog)) {\n            Util.execCommand(\n                'Upload delta package results file',\n                'copado --uploadfile ' + CONFIG.deltaPackageLog,\n                'Completed uploading delta package results file'\n            );\n        }\n\n        if (fs.existsSync(deployFolder)) {\n            const deltaPackageFiles = fs.readdirSync(deployFolder);\n            if (null != deltaPackageFiles) {\n                Log.debug('Found ' + deltaPackageFiles.length + ' files to deploy');\n                if (0 < deltaPackageFiles.length) {\n                    return true;\n                }\n            } else {\n                Log.debug('Could not find any files to deploy in folder ' + deployFolder);\n            }\n        } else {\n            Log.debug('Could not find deploy folder ' + deployFolder);\n        }\n        return false;\n    }\n\n    /**\n     * Returns the to branch to use when accessing MC Dev configuration\n     * The branch is the normal PR to branch, except if the PR is for a release or hotfix.\n     * Release- and hotfix branches have a detailed release or hotfix number in the branch name,\n     * and rather than using these detailed names the configuration used only 'release' resp. 'hotfix'.\n     * @param {string} branch value from copado config\n     * @returns {string} toBranch value to look for in config\n     */\n    static _getConfigForToBranch(branch) {\n        let configBranch = branch;\n        if (branch.startsWith('release/')) {\n            configBranch = 'release/*';\n        } else if (branch.startsWith('hotfix/')) {\n            configBranch = 'hotfix/*';\n        }\n        Log.debug('Config branch for branch ' + branch + ' is ' + configBranch);\n        return configBranch;\n    }\n\n    /**\n     * Determines the list of BUs from MC Dev configuration (.mcdev.json)\n     * to which changes should be deployed.\n     * @returns {string[]} List of BUs\n     */\n    static getDeployTargetBUs() {\n        if (!fs.existsSync(CONFIG.configFilePath)) {\n            throw new Error('Could not find config file ' + CONFIG.configFilePath);\n        }\n        const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, 'utf8'));\n        const configToBranch = Deploy._getConfigForToBranch(CONFIG.toBranch);\n        const options = config['options'];\n        if (null == options) {\n            throw new Error('Could not find options in ' + CONFIG.configFilePath);\n        }\n        const deployment = options['deployment'];\n        if (null == deployment) {\n            throw new Error('Could not find options/deployment in ' + CONFIG.configFilePath);\n        }\n        const targetBranchBuMapping = deployment['targetBranchBuMapping'];\n        if (null == targetBranchBuMapping) {\n            throw new Error(\n                'Could not find options/deployment/targetBranchBuMapping in ' +\n                    CONFIG.configFilePath\n            );\n        }\n        let bus = targetBranchBuMapping[configToBranch];\n        if (null == bus) {\n            throw new Error(\n                'Could not find config branch ' +\n                    configToBranch +\n                    ' in options/deployment/targetBranchBuMapping in ' +\n                    CONFIG.configFilePath\n            );\n        }\n        if (bus instanceof String) {\n            bus = [bus];\n        }\n        Log.debug('BUs to deploy for config branch ' + configToBranch + ' are: ' + bus.join());\n        return bus;\n    }\n\n    /**\n     * Deploys one specific BU.\n     * In case of errors, the deployment is not stopped.\n     * @param {string} bu name of BU\n     * @returns {number} exit code of the deployment\n     */\n    static deployBU(bu) {\n        const ec = Util.execCommandReturnStatus(\n            'Deploy BU ' + bu,\n            'cd /tmp && ' + CONFIG.mcdev + ' deploy ' + bu,\n            'Completed deploying BU'\n        );\n        if (0 != ec) {\n            Log.warn(\n                'Deployment of BU ' +\n                    bu +\n                    ' failed with exit code ' +\n                    ec +\n                    '. Other BUs will be deployed, but overall deployment will fail at the end.'\n            );\n            // logError(\"Deployment of BU \" + bu + \" failed with exit code \" + ec + \". Other BUs will be deployed, but overall deployment will fail at the end.\");\n            // Log.info(\"Deployment of BU \" + bu + \" failed with exit code \" + ec + \". Other BUs will be deployed, but overall deployment will fail at the end.\");\n            // console.log(\"Deployment of BU \" + bu + \" failed with exit code \" + ec + \". Other BUs will be deployed, but overall deployment will fail at the end.\");\n        }\n\n        return ec;\n    }\n}\n\n/**\n * methods to handle interaction with the copado platform\n */\nclass Copado {\n    /**\n     * Finally, attach the resulting metadata JSON.\n     * @param {string} metadataFilePath where we stored the temporary json file\n     * @returns {void}\n     */\n    static attachJson(metadataFilePath) {\n        Util.execCommand(\n            'Attach JSON ' + metadataFilePath,\n            'cd /tmp && copado --uploadfile \"' +\n                metadataFilePath +\n                '\" --parentid \"' +\n                CONFIG.envId +\n                '\"',\n            'Completed attaching JSON'\n        );\n    }\n    /**\n     * Checks out the source repository.\n     * if a feature branch is available creates\n     * the feature branch based on the main branch.\n     * @param {string} mainBranch ?\n     * @param {string} featureBranch can be null/undefined\n     * @returns {void}\n     */\n    static checkoutSrc(mainBranch, featureBranch) {\n        Util.execCommand(\n            'Cloning and checking out the main branch ' + mainBranch,\n            'cd /tmp && copado-git-get \"' + mainBranch + '\"',\n            'Completed cloning/checking out main branch'\n        );\n        if (featureBranch) {\n            Util.execCommand(\n                'Creating resp. checking out the feature branch ' + featureBranch,\n                'cd /tmp && copado-git-get --create \"' + featureBranch + '\"',\n                'Completed creating/checking out feature branch'\n            );\n        }\n    }\n    /**\n     * Checks out the source repository and branch\n     * @param {string} fromCommit commit id to merge\n     * @param {string} toBranch branch name to merge into\n     * @returns {void}\n     */\n    static checkoutSrcDeploy(fromCommit, toBranch) {\n        // First make sure that the from branch is available\n        Util.execCommand(\n            'Cloning resp. checking out the repository commit/branch ' + fromCommit,\n            'cd /tmp && copado-git-get -d . ' + fromCommit,\n            'Completed cloning commit/branch'\n        );\n\n        // Now checkout the target branch.\n        // That branch/commit that contains changed files should be checked out.\n        // When working with PRs, this is the target branch, after the source branch\n        // has been merged into this branch. So basically the version range to deploy\n        // is HEAD^..HEAD.\n        Util.execCommand(\n            'Cloning resp. checking out the repository branch ' + toBranch,\n            'cd /tmp && copado-git-get -d . ' + toBranch,\n            'Completed cloning branch'\n        );\n    }\n    /**\n     * Merge from branch into target branch\n     * @param {string} fromCommit commit id to merge\n     * @returns {void}\n     */\n    static merge(fromCommit) {\n        // Merge and commit changes.\n        Util.execCommand(\n            'Merge commit ' + fromCommit,\n            'cd /tmp && git merge \"' + fromCommit + '\"',\n            'Completed merging commit'\n        );\n    }\n    /**\n     * Pushes after a successfull deployment\n     * @param {string} toBranch name of branch to push to\n     * @returns {void}\n     */\n    static push(toBranch) {\n        Util.execCommand(\n            'Push branch ' + toBranch,\n            'cd /tmp && git push origin \"' + toBranch + '\"',\n            'Completed pushing branch'\n        );\n    }\n\n    /**\n     * Promote changes by merging into the promotion branch\n     * @param {string} toBranch branch to merge into\n     * @param {string} promotionBranch target branch to merge into\n     * @returns {void}\n     */\n    static promote(toBranch) {\n        // Util.execCommand(\"Checking out the branch \" + toBranch,\n        //            \"cd /tmp && copado-git-get --depth \" + git_depth + ' ' + toBranch,\n        //            \"Completed cloning branch\");\n        Util.execCommand(\n            'Checking out the branch ' + CONFIG.promotionBranch,\n            'cd /tmp && copado-git-get --depth ' + CONFIG.git_depth + ' ' + CONFIG.promotionBranch,\n            'Completed cloning branch'\n        );\n        const mergeOption = CONFIG.merge_strategy ? '-X ' + CONFIG.merge_strategy + ' ' : '';\n        Util.execCommand(\n            'Merge commit ' + toBranch,\n            'cd /tmp && git merge ' +\n                mergeOption +\n                '-m \"Auto merge ' +\n                toBranch +\n                '\" \"' +\n                toBranch +\n                '\"',\n            'Completed merging'\n        );\n\n        Util.execCommand(\n            'Push branch ' + CONFIG.promotionBranch,\n            'cd /tmp && git push origin \"' + CONFIG.promotionBranch + '\"',\n            'Completed pushing branch'\n        );\n    }\n}\n\nLog.info('Deploy.js started');\nLog.debug('');\nLog.debug('Parameters');\nLog.debug('==========');\nLog.debug('');\nLog.debug(`fromCommit        = ${CONFIG.fromCommit}`);\nLog.debug(`toBranch          = ${CONFIG.toBranch}`);\nLog.debug('');\nLog.debug(`mcdevVersion      = ${CONFIG.mcdevVersion}`);\nLog.debug(`credentialName    = ${CONFIG.credentialName}`);\n\nLog.info('');\nLog.info('Clone repository');\nLog.info('================');\nLog.info('');\nCopado.checkoutSrcDeploy(CONFIG.fromCommit, CONFIG.toBranch);\n\nLog.info('');\nLog.info('Merge branch');\nLog.info('============');\nLog.info('');\nCopado.merge(CONFIG.fromCommit);\n\nLog.info('');\nLog.info('Preparing');\nLog.info('=========');\nLog.info('');\nUtil.provideMCDevTools();\n\nLog.info('');\nLog.info('Initialize project');\nLog.info('==================');\nLog.info('');\nUtil.initProject();\n\nLog.info('');\nLog.info('Determine deploy folder');\nLog.info('=======================');\nLog.info('');\nconst deployFolder = Deploy.getDeployFolder();\n\nLog.info('');\nLog.info('Create delta package');\nLog.info('====================');\nLog.info('');\nif (true == Deploy.createDeltaPackage('/tmp/' + deployFolder)) {\n    const bus = Deploy.getDeployTargetBUs();\n\n    Log.info('Deploy BUs');\n    Log.info('----------');\n    let exitCode = 0;\n    bus.forEach((bu) => {\n        const ec = Deploy.deployBU(bu);\n        if (0 != ec) {\n            if (0 == exitCode) {\n                exitCode = ec;\n            }\n        }\n    });\n    if (0 != exitCode) {\n        throw new Error('Deployment of at least one BU failed. See previous output for details');\n    }\n\n    Log.info('Commit and push changes');\n    Log.info('-----------------------');\n    Copado.push(CONFIG.toBranch);\n}\n\nLog.info('');\nLog.info('Merge into promotion branch');\nLog.info('===========================');\nLog.info('');\nCopado.promote(CONFIG.toBranch, CONFIG.promotionBranch);\n\nLog.info('');\nLog.info('Finished');\nLog.info('========');\nLog.info('');\nLog.info('Deploy.js done');",
          "copado__Timeout__c": 5,
          "copado__Type__c": "Custom",
          "copado__Worker_Size__c": "S",
          "CreatedDate": "2021-08-20T13:38:35.000+0000",
          "Id": "a1t09000000YGtPAAW",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-21T10:04:45.000+0000",
          "LastReferencedDate": "2022-01-21T10:04:47.000+0000",
          "LastViewedDate": "2022-01-21T10:04:47.000+0000",
          "Name": "Marketing Cloud Deploy",
          "SystemModstamp": "2022-01-21T10:04:45.000+0000"
        },
        {
          "attributes": {
            "type": "copado__Function__c",
            "url": "/services/data/v54.0/sobjects/copado__Function__c/a1t09000000YHfjAAG"
          },
          "copado__API_Name__c": "MC_Retrieve",
          "copado__Image_Name__c": "us.gcr.io/copado-backend-functions-prod/copado-multicloud-git-utils:v1",
          "copado__Options__c": "[ ]",
          "copado__Parameters__c": "[ {\n  \"required\" : false,\n  \"name\" : \"envId\"\n}, {\n  \"name\" : \"main_branch\",\n  \"defaultValue\" : \"master\"\n}, {\n  \"name\" : \"mcdev_version\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_devtools_version}\"\n}, {\n  \"name\" : \"credentialName\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_credential_name}\"\n}, {\n  \"name\" : \"clientId\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_client_id}\"\n}, {\n  \"name\" : \"clientSecret\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_client_secret}\"\n}, {\n  \"name\" : \"tenant\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_tenant}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n} ]",
          "copado__Script__c": "#!/usr/bin/env node\n\n/**\n * @typedef {Object} MetadataItem\n * @property {string} n Name\n * @property {string} k Key (Customer Key / External Key)\n * @property {string} t metadata type\n * @property {string} [cd] created date\n * @property {string} [cb] created by name\n * @property {string} [ld] last modified date\n * @property {string} [lb] last modified by name\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst execSync = require('child_process').execSync;\n\nconst CONFIG = {\n    // generic\n    clientId: process.env.clientId,\n    clientSecret: process.env.clientSecret,\n    configFilePath: '/tmp/.mcdevrc.json',\n    credentialName: process.env.credentialName,\n    debug: true,\n    envId: process.env.envId,\n    mainBranch: process.env.main_branch,\n    mcdev: 'node ./node_modules/mcdev/lib/index.js',\n    mcdevVersion: process.env.mcdev_version,\n    metadataFilePath: '/tmp/mcmetadata.json',\n    tenant: process.env.tenant,\n    // commit\n    commitMessage: null,\n    featureBranch: null,\n    metadataFile: null,\n    metadataFileName: null,\n    // deploy\n    deltaPackageLog: null,\n    fromCommit: null, // The source branch of a PR, typically something like 'feature/...'\n    git_depth: null, // set a default git depth of 100 commits\n    merge_strategy: null, // set default merge strategy\n    promotionBranch: null, // The promotion branch of a PR\n    toBranch: null, // The target branch of a PR, like master. This commit will be lastly checked out\n};\n\n/**\n * logger class\n */\nclass Log {\n    /**\n     * constructor\n     */\n    constructor() {}\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static debug(msg) {\n        if (true == CONFIG.debug) {\n            console.log(msg);\n        }\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static warn(msg) {\n        console.log(msg);\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static info(msg) {\n        console.log(msg);\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static error(msg) {\n        Log.warn(msg);\n        execSync(\"copado --error-message '\" + msg + \"'\");\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static progress(msg) {\n        Log.debug(msg);\n        execSync(\"copado --progress '\" + msg + \"'\");\n    }\n}\n\n/**\n * helper class\n */\nclass Util {\n    /**\n     * Execute command\n     * @param {string} [preMsg] the message displayed to the user in copado before execution\n     * @param {string} command the cli command to execute synchronously\n     * @param {string} [postMsg] the message displayed to the user in copado after execution\n     * @returns {void}\n     */\n    static execCommand(preMsg, command, postMsg) {\n        if (null != preMsg) {\n            Log.progress(preMsg);\n        }\n        Log.debug(command);\n\n        try {\n            execSync(command, { stdio: 'inherit', stderr: 'inherit' });\n        } catch (error) {\n            Log.error(error.status + ': ' + error.message);\n            throw new Error(error);\n        }\n\n        if (null != postMsg) {\n            Log.progress(postMsg);\n        }\n    }\n\n    /**\n     * Execute command but return the exit code\n     * @param {string} [preMsg] the message displayed to the user in copado before execution\n     * @param {string} command the cli command to execute synchronously\n     * @param {string} [postMsg] the message displayed to the user in copado after execution\n     * @return {number} exit code\n     */\n    static execCommandReturnStatus(preMsg, command, postMsg) {\n        if (null != preMsg) {\n            Log.progress(preMsg);\n        }\n        Log.debug(command);\n\n        let exitCode = null;\n        try {\n            execSync(command, { stdio: 'inherit', stderr: 'inherit' });\n\n            // Seems command finished successfully, so change exit code from null to 0\n            exitCode = 0;\n        } catch (error) {\n            Log.warn(error.status + ': ' + error.message);\n\n            // The command failed, take the exit code from the error\n            exitCode = error.status;\n        }\n\n        if (null != postMsg) {\n            Log.progress(postMsg);\n        }\n\n        return exitCode;\n    }\n\n    /**\n     * Installs MC Dev Tools and prints the version number\n     * TODO: This will later be moved into an according Docker container.\n     * @returns {void}\n     */\n    static provideMCDevTools() {\n        Util.execCommand(\n            'Initializing npm',\n            'cd /tmp && npm init -y',\n            'Completed initializing NPM'\n        );\n\n        Util.execCommand(\n            'Initializing MC Dev Tools version ' + CONFIG.mcdevVersion,\n            'cd /tmp && npm install --save mcdev@' +\n                CONFIG.mcdevVersion +\n                ' --foreground-scripts && ' +\n                CONFIG.mcdev +\n                ' --version',\n            'Completed installing MC Dev Tools'\n        );\n    }\n\n    /**\n     * Initializes MC project\n     * @returns {void}\n     */\n    static initProject() {\n        // ! UPDATE NEEDED\n        // TODO make eid configurable!!!\n        const authJson = `{\n            \"credentials\": {\n                \"${CONFIG.credentialName}\": {\n                    \"clientId\": \"${CONFIG.clientId}\",\n                    \"clientSecret\": \"${CONFIG.clientSecret}\",\n                    \"tenant\": \"${CONFIG.tenant}\",\n                    \"eid\": \"7281698\"\n                }\n            }\n        }`;\n        Log.progress('Provide authentication');\n        fs.writeFileSync('/tmp/.mcdev-auth.json', authJson);\n        Log.progress('Completed providing authentication');\n        // The following command fails for an unknown reason.\n        // As workaround, provide directly the authentication file. This is also faster.\n        // Util.execCommand(\"Initializing MC project with credential name \" + credentialName + \" for tenant \" + tenant,\n        //            \"cd /tmp && \" + mcdev + \" init --y.credentialsName \" + credentialName + \" --y.clientId \" + clientId + \" --y.clientSecret \" + clientSecret + \" --y.tenant \" + tenant + \" --y.gitRemoteUrl \" + remoteUrl,\n        //            \"Completed initializing MC project\");\n    }\n}\n\n/**\n * handles downloading metadata\n */\nclass Retrieve {\n    /**\n     * Determines the retrieve folder from MC Dev configuration (.mcdev.json)\n     * TODO: replace by simply requiring the config file\n     * @returns {string} retrieve folder\n     */\n    static getRetrieveFolder() {\n        if (!fs.existsSync(CONFIG.configFilePath)) {\n            throw new Error('Could not find config file ' + CONFIG.configFilePath);\n        }\n        const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, 'utf8'));\n        const directories = config['directories'];\n        if (null == directories) {\n            throw new Error('Could not find directories in ' + CONFIG.configFilePath);\n        }\n        const folder = directories['retrieve'];\n        if (null == folder) {\n            throw new Error('Could not find directories/retrieve in ' + CONFIG.configFilePath);\n        }\n\n        Log.debug('Retrieve folder is: ' + folder);\n        return folder;\n    }\n\n    /**\n     * Determines the BU from MC Dev configuration (.mcdev.json)\n     * from which to retrieve components.\n     * TODO: replace by simply requiring the config file\n     * @returns {string} BU\n     */\n    static getSourceBU() {\n        if (!fs.existsSync(CONFIG.configFilePath)) {\n            throw new Error('Could not find config file ' + CONFIG.configFilePath);\n        }\n        const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, 'utf8'));\n        const options = config['options'];\n        if (null == options) {\n            throw new Error('Could not find options in ' + CONFIG.configFilePath);\n        }\n        const deployment = options['deployment'];\n        if (null == deployment) {\n            throw new Error('Could not find options/deployment in ' + CONFIG.configFilePath);\n        }\n        const sourceTargetMapping = deployment['sourceTargetMapping'];\n        if (null == sourceTargetMapping) {\n            throw new Error(\n                'Could not find options/deployment/sourceTargetMapping in ' + CONFIG.configFilePath\n            );\n        }\n        const sourceTargetMappingKeys = Object.keys(sourceTargetMapping);\n        if (null == sourceTargetMappingKeys || 1 != sourceTargetMappingKeys.length) {\n            throw new Error(\n                'Got unexpected number of keys in options/deployment/sourceTargetMapping in ' +\n                    CONFIG.configFilePath +\n                    '. Expected is only one entry'\n            );\n        }\n\n        const marketList = config['marketList'];\n        if (null == marketList) {\n            throw new Error('Could not find marketList in ' + CONFIG.configFilePath);\n        }\n        const deploymentSource = marketList[sourceTargetMappingKeys[0]];\n        if (null == deploymentSource) {\n            throw new Error(\n                'Could not find marketList/ ' +\n                    deploymentSourceKeys[0] +\n                    ' in ' +\n                    CONFIG.configFilePath\n            );\n        }\n        const deploymentSourceKeys = Object.keys(deploymentSource);\n        if (\n            null == deploymentSourceKeys ||\n            (1 != deploymentSourceKeys.length && 2 != deploymentSourceKeys.length)\n        ) {\n            throw new Error(\n                'Got unexpected number of keys in marketList/' +\n                    deploymentSource +\n                    ' in ' +\n                    CONFIG.configFilePath +\n                    '. Expected is one entry, or two in case there is a description entry.'\n            );\n        }\n        let sourceBU = null;\n        if ('description' != deploymentSourceKeys[0]) {\n            sourceBU = deploymentSourceKeys[0];\n        } else {\n            sourceBU = deploymentSourceKeys[1];\n        }\n\n        Log.debug('BU to retrieve is: ' + sourceBU);\n        return sourceBU;\n    }\n\n    /**\n     * Retrieve components into a clean retrieve folder.\n     * The retrieve folder is deleted before retrieving to make\n     * sure we have only components that really exist in the BU.\n     * TODO: replace execCommand with call to required mcdev\n     * @param {string} sourceBU specific subfolder for downloads\n     * @param {string} [retrieveFolder] place where mcdev will download to\n     * @returns {void}\n     */\n    static retrieveComponents(sourceBU, retrieveFolder) {\n        if (retrieveFolder) {\n            const retrievePath = path.join('/tmp', retrieveFolder, sourceBU);\n            let retrievePathFixed = retrievePath;\n            if (retrievePath.endsWith('/') || retrievePath.endsWith('\\\\')) {\n                retrievePathFixed = retrievePath.substring(0, retrievePath.length - 1);\n            }\n            Log.info('Delete retrieve folder ' + retrievePathFixed);\n            fs.rmSync(retrievePathFixed, { recursive: true, force: true });\n        }\n        // TODO: should use the retrieve logic from mcdev's retrieveChangelog.js instead\n        Util.execCommand(\n            'Retrieve components from ' + sourceBU,\n            'cd /tmp && ' + CONFIG.mcdev + ' retrieve ' + sourceBU + ' --skipInteraction',\n            'Completed retrieving components'\n        );\n    }\n}\n\n/**\n * handles creating the metadata json that we store for copado after retrieving it\n */\nclass Metadata {\n    /**\n     * After components have been retrieved,\n     * find all retrieved components and build a json containing as much\n     * metadata as possible.\n     * @param {string} retrieveFolder path where downloaded files are\n     * @param {string} sourceBU subfolder for BU\n     * @param {string} metadataFilePath filename & path to where we store the final json for copado\n     * @returns {void}\n     */\n    static createMetadataFile(retrieveFolder, sourceBU, metadataFilePath) {\n        const retrievePath = path.join('/tmp', retrieveFolder, sourceBU);\n        let retrievePathFixed = retrievePath;\n        if (retrievePath.endsWith('/') || retrievePath.endsWith('\\\\')) {\n            retrievePathFixed = retrievePath.substring(0, retrievePath.length - 1);\n        }\n        /**\n         * @type {MetadataItem}\n         */\n        const metadataJson = [];\n        Metadata._buildMetadataJson(retrievePathFixed, sourceBU, metadataJson);\n        const metadataString = JSON.stringify(metadataJson);\n        // Log.debug('Metadata JSON is: ' + metadataString);\n        fs.writeFileSync(metadataFilePath, metadataString);\n    }\n\n    /**\n     * After components have been retrieved,\n     * find all retrieved components and build a json containing as much\n     * metadata as possible.\n     * @private\n     * @param {string} retrieveFolder path where downloaded files are\n     * @param {string} sourceBU subfolder for BU\n     * @param {MetadataItem[]} metadataJson reference to array that we want to pass to copado\n     * @returns {void}\n     */\n    static _buildMetadataJson(retrieveFolder, sourceBU, metadataJson) {\n        // Handle files within the current directory\n        const filesAndFolders = fs\n            .readdirSync(retrieveFolder)\n            .map((entry) => path.join(retrieveFolder, entry));\n        filesAndFolders.forEach((filePath) => {\n            if (fs.statSync(filePath).isFile()) {\n                const dirName = path.dirname(filePath);\n                const componentType = path.basename(dirName);\n\n                let componentJson;\n                switch (componentType) {\n                    case 'automation':\n                        Log.debug('Handle component ' + filePath + ' with type ' + componentType);\n                        componentJson = Metadata._buildAutomationMetadataJson(filePath);\n                        break;\n                    case 'dataExtension':\n                        Log.debug('Handle component ' + filePath + ' with type ' + componentType);\n                        componentJson = Metadata._buildDataExtensionMetadataJson(filePath);\n                        break;\n                    default:\n                        throw new Error(\n                            'Component ' +\n                                filePath +\n                                ' with type ' +\n                                componentType +\n                                ' is not supported'\n                        );\n                }\n\n                // Log.debug('Metadata JSON for component ' + filePath + ' is: ' + JSON.stringify(componentJson));\n                metadataJson.push(componentJson);\n            }\n        });\n\n        // Get folders within the current directory\n        filesAndFolders.forEach((folderPath) => {\n            if (fs.statSync(folderPath).isDirectory()) {\n                Metadata._buildMetadataJson(folderPath, sourceBU, metadataJson);\n            }\n        });\n    }\n\n    /**\n     * Build the metadata JSON for a automation component\n     * @private\n     * @param {string} filePath path to json\n     * @param {string} [action] pass in value do govern what to do\n     * @returns {MetadataItem} one table row\n     */\n    static _buildAutomationMetadataJson(filePath, action) {\n        // Load the file\n        const parsed = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n\n        const metadata = {};\n        metadata['n'] = parsed['name'] ? parsed['name'] : parsed['key'];\n        metadata['k'] = parsed['key'];\n        metadata['t'] = 'automation';\n        // metadata['cd'] = parsed[''];\n        // metadata['cb'] = parsed[''];\n        // metadata['ld'] = parsed[''];\n        // metadata['lb'] = parsed[''];\n\n        if (action) {\n            metadata.a = action;\n        }\n\n        return metadata;\n    }\n\n    /**\n     * Build the metadata JSON for a data extension component\n     * @private\n     * @param {string} filePath path to json\n     * @param {string} [action] pass in value do govern what to do\n     * @returns {MetadataItem} one table row\n     */\n    static _buildDataExtensionMetadataJson(filePath, action) {\n        // Load the file\n        const parsed = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n\n        const metadata = {};\n        metadata['n'] = parsed['Name'] ? parsed['Name'] : parsed['CustomerKey'];\n        metadata['k'] = parsed['CustomerKey'];\n        metadata['t'] = 'dataExtension';\n        metadata['cd'] = parsed['CreatedDate'];\n        // metadata['cb'] = parsed[''];\n        // metadata['ld'] = parsed[''];\n        // metadata['lb'] = parsed[''];\n\n        if (action) {\n            metadata.a = action;\n        }\n\n        return metadata;\n    }\n}\n\n/**\n * methods to handle interaction with the copado platform\n */\nclass Copado {\n    /**\n     * Finally, attach the resulting metadata JSON.\n     * @param {string} metadataFilePath where we stored the temporary json file\n     * @returns {void}\n     */\n    static attachJson(metadataFilePath) {\n        Util.execCommand(\n            'Attach JSON ' + metadataFilePath,\n            'cd /tmp && copado --uploadfile \"' +\n                metadataFilePath +\n                '\" --parentid \"' +\n                CONFIG.envId +\n                '\"',\n            'Completed attaching JSON'\n        );\n    }\n\n    /**\n     * Checks out the source repository.\n     * if a feature branch is available creates\n     * the feature branch based on the main branch.\n     * @param {string} mainBranch ?\n     * @param {string} featureBranch can be null/undefined\n     * @returns {void}\n     */\n    static checkoutSrc(mainBranch, featureBranch) {\n        Util.execCommand(\n            'Cloning and checking out the main branch ' + mainBranch,\n            'cd /tmp && copado-git-get \"' + mainBranch + '\"',\n            'Completed cloning/checking out main branch'\n        );\n        if (featureBranch) {\n            Util.execCommand(\n                'Creating resp. checking out the feature branch ' + featureBranch,\n                'cd /tmp && copado-git-get --create \"' + featureBranch + '\"',\n                'Completed creating/checking out feature branch'\n            );\n        }\n    }\n}\n\nLog.info('Retrieve.js started');\nLog.debug('');\nLog.debug('Parameters');\nLog.debug('==========');\nLog.debug('');\nLog.debug(`mainBranch        = ${CONFIG.mainBranch}`);\nLog.debug(`envId             = ${CONFIG.envId}`);\nLog.debug('');\nLog.debug(`mcdevVersion      = ${CONFIG.mcdevVersion}`);\nLog.debug(`credentialName    = ${CONFIG.credentialName}`);\n// Log.debug(`clientId          = ${clientId}`);\n// Log.debug(`clientSecret      = ${clientSecret}`);\n// Log.debug(`tenant            = ${tenant}`);\n\nLog.info('');\nLog.info('Clone repository');\nLog.info('================');\nLog.info('');\nCopado.checkoutSrc(CONFIG.mainBranch);\n\nLog.info('');\nLog.info('Preparing');\nLog.info('=========');\nLog.info('');\nUtil.provideMCDevTools();\n\nLog.info('');\nLog.info('Initialize project');\nLog.info('==================');\nLog.info('');\nUtil.initProject();\n\nLog.info('');\nLog.info('Determine retrieve folder');\nLog.info('=========================');\nLog.info('');\nconst retrieveFolder = Retrieve.getRetrieveFolder();\n\nLog.info('');\nLog.info('Get source BU');\nLog.info('=============');\nLog.info('');\nconst sourceBU = Retrieve.getSourceBU();\n\nLog.info('');\nLog.info('Retrieve components');\nLog.info('===================');\nLog.info('');\nRetrieve.retrieveComponents(sourceBU, retrieveFolder);\n\nLog.info('');\nLog.info('Build metadata JSON');\nLog.info('===================');\nLog.info('');\nMetadata.createMetadataFile(retrieveFolder, sourceBU, CONFIG.metadataFilePath);\n\nLog.info('');\nLog.info('Attach JSON');\nLog.info('===========');\nLog.info('');\nCopado.attachJson(CONFIG.metadataFilePath);\nLog.info('');\nLog.info('Finished');\nLog.info('========');\nLog.info('');\nLog.info('Retrieve.js done');",
          "copado__Timeout__c": 5,
          "copado__Type__c": "Custom",
          "copado__Worker_Size__c": "S",
          "CreatedDate": "2021-08-27T10:01:35.000+0000",
          "Id": "a1t09000000YHfjAAG",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-21T10:05:51.000+0000",
          "LastReferencedDate": "2022-01-21T10:05:51.000+0000",
          "LastViewedDate": "2022-01-21T10:05:51.000+0000",
          "Name": "Marketing Cloud Retrieve",
          "SystemModstamp": "2022-01-21T10:05:51.000+0000"
        },
        {
          "attributes": {
            "type": "copado__Function__c",
            "url": "/services/data/v54.0/sobjects/copado__Function__c/a1t09000000YHwxAAG"
          },
          "copado__API_Name__c": "MC_Commit",
          "copado__Image_Name__c": "us.gcr.io/copado/copado-function-core:v1",
          "copado__Options__c": "[ ]",
          "copado__Parameters__c": "[ {\n  \"required\" : false,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"feature_branch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.featureBranchName}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"main_branch\",\n  \"defaultValue\" : \"master\"\n}, {\n  \"name\" : \"mcdev_version\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_devtools_version}\"\n}, {\n  \"name\" : \"credentialName\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_credential_name}\"\n}, {\n  \"name\" : \"clientId\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_client_id}\"\n}, {\n  \"name\" : \"clientSecret\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_client_secret}\"\n}, {\n  \"name\" : \"tenant\",\n  \"defaultValue\" : \"{$Pipeline.Property.mc_tenant}\"\n}, {\n  \"name\" : \"commit_message\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.message}\"\n}, {\n  \"name\" : \"metadata_file\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"\n} ]",
          "copado__Script__c": "#!/usr/bin/env node\n\n/**\n * @typedef {Object} MetadataItem\n * @property {string} n Name\n * @property {string} k Key (Customer Key / External Key)\n * @property {string} t metadata type\n * @property {string} [cd] created date\n * @property {string} [cb] created by name\n * @property {string} [ld] last modified date\n * @property {string} [lb] last modified by name\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst execSync = require('child_process').execSync;\n\nconst CONFIG = {\n    // generic\n    clientId: process.env.clientId,\n    clientSecret: process.env.clientSecret,\n    configFilePath: '/tmp/.mcdevrc.json',\n    credentialName: process.env.credentialName,\n    debug: true,\n    envId: process.env.envId,\n    mainBranch: process.env.main_branch,\n    mcdev: 'node ./node_modules/mcdev/lib/index.js',\n    mcdevVersion: process.env.mcdev_version,\n    metadataFilePath: '/tmp/mcmetadata.json',\n    tenant: process.env.tenant,\n    // commit\n    commitMessage: process.env.commit_message,\n    featureBranch: process.env.feature_branch,\n    metadataFile: process.env.metadata_file, // TODO: check if this duplicates CONFIG.metadataFilePath\n    metadataFileName: 'Copado Commit changes.json',\n    // deploy\n    deltaPackageLog: null,\n    fromCommit: null, // The source branch of a PR, typically something like 'feature/...'\n    git_depth: null, // set a default git depth of 100 commits\n    merge_strategy: null, // set default merge strategy\n    promotionBranch: null, // The promotion branch of a PR\n    toBranch: null, // The target branch of a PR, like master. This commit will be lastly checked out\n};\n\n/**\n * logger class\n */\nclass Log {\n    /**\n     * constructor\n     */\n    constructor() {}\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static debug(msg) {\n        if (true == CONFIG.debug) {\n            console.log(msg);\n        }\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static warn(msg) {\n        console.log(msg);\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static info(msg) {\n        console.log(msg);\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static error(msg) {\n        Log.warn(msg);\n        execSync(\"copado --error-message '\" + msg + \"'\");\n    }\n    /**\n     * @param {string} msg your log message\n     * @returns {void}\n     */\n    static progress(msg) {\n        Log.debug(msg);\n        execSync(\"copado --progress '\" + msg + \"'\");\n    }\n}\n\n/**\n * helper class\n */\nclass Util {\n    /**\n     * Execute command\n     * @param {string} [preMsg] the message displayed to the user in copado before execution\n     * @param {string} command the cli command to execute synchronously\n     * @param {string} [postMsg] the message displayed to the user in copado after execution\n     * @returns {void}\n     */\n    static execCommand(preMsg, command, postMsg) {\n        if (null != preMsg) {\n            Log.progress(preMsg);\n        }\n        Log.debug(command);\n\n        try {\n            execSync(command, { stdio: 'inherit', stderr: 'inherit' });\n        } catch (error) {\n            Log.error(error.status + ': ' + error.message);\n            throw new Error(error);\n        }\n\n        if (null != postMsg) {\n            Log.progress(postMsg);\n        }\n    }\n\n    /**\n     * Execute command but return the exit code\n     * @param {string} [preMsg] the message displayed to the user in copado before execution\n     * @param {string} command the cli command to execute synchronously\n     * @param {string} [postMsg] the message displayed to the user in copado after execution\n     * @return {number} exit code\n     */\n    static execCommandReturnStatus(preMsg, command, postMsg) {\n        if (null != preMsg) {\n            Log.progress(preMsg);\n        }\n        Log.debug(command);\n\n        let exitCode = null;\n        try {\n            execSync(command, { stdio: 'inherit', stderr: 'inherit' });\n\n            // Seems command finished successfully, so change exit code from null to 0\n            exitCode = 0;\n        } catch (error) {\n            Log.warn(error.status + ': ' + error.message);\n\n            // The command failed, take the exit code from the error\n            exitCode = error.status;\n        }\n\n        if (null != postMsg) {\n            Log.progress(postMsg);\n        }\n\n        return exitCode;\n    }\n\n    /**\n     * Installs MC Dev Tools and prints the version number\n     * TODO: This will later be moved into an according Docker container.\n     * @returns {void}\n     */\n    static provideMCDevTools() {\n        Util.execCommand(\n            'Initializing npm',\n            'cd /tmp && npm init -y',\n            'Completed initializing NPM'\n        );\n\n        Util.execCommand(\n            'Initializing MC Dev Tools version ' + CONFIG.mcdevVersion,\n            'cd /tmp && npm install --save mcdev@' +\n                CONFIG.mcdevVersion +\n                ' --foreground-scripts && ' +\n                CONFIG.mcdev +\n                ' --version',\n            'Completed installing MC Dev Tools'\n        );\n    }\n\n    /**\n     * Initializes MC project\n     * @returns {void}\n     */\n    static initProject() {\n        // ! UPDATE NEEDED\n        // TODO make eid configurable!!!\n        const authJson = `{\n            \"credentials\": {\n                \"${CONFIG.credentialName}\": {\n                    \"clientId\": \"${CONFIG.clientId}\",\n                    \"clientSecret\": \"${CONFIG.clientSecret}\",\n                    \"tenant\": \"${CONFIG.tenant}\",\n                    \"eid\": \"7281698\"\n                }\n            }\n        }`;\n        Log.progress('Provide authentication');\n        fs.writeFileSync('/tmp/.mcdev-auth.json', authJson);\n        Log.progress('Completed providing authentication');\n        // The following command fails for an unknown reason.\n        // As workaround, provide directly the authentication file. This is also faster.\n        // Util.execCommand(\"Initializing MC project with credential name \" + credentialName + \" for tenant \" + tenant,\n        //            \"cd /tmp && \" + mcdev + \" init --y.credentialsName \" + credentialName + \" --y.clientId \" + clientId + \" --y.clientSecret \" + clientSecret + \" --y.tenant \" + tenant + \" --y.gitRemoteUrl \" + remoteUrl,\n        //            \"Completed initializing MC project\");\n    }\n}\n\n/**\n * handles downloading metadata\n */\nclass Retrieve {\n    /**\n     * Determines the retrieve folder from MC Dev configuration (.mcdev.json)\n     * TODO: replace by simply requiring the config file\n     * @returns {string} retrieve folder\n     */\n    static getRetrieveFolder() {\n        if (!fs.existsSync(CONFIG.configFilePath)) {\n            throw new Error('Could not find config file ' + CONFIG.configFilePath);\n        }\n        const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, 'utf8'));\n        const directories = config['directories'];\n        if (null == directories) {\n            throw new Error('Could not find directories in ' + CONFIG.configFilePath);\n        }\n        const folder = directories['retrieve'];\n        if (null == folder) {\n            throw new Error('Could not find directories/retrieve in ' + CONFIG.configFilePath);\n        }\n\n        Log.debug('Retrieve folder is: ' + folder);\n        return folder;\n    }\n\n    /**\n     * Determines the BU from MC Dev configuration (.mcdev.json)\n     * from which to retrieve components.\n     * TODO: replace by simply requiring the config file\n     * @returns {string} BU\n     */\n    static getSourceBU() {\n        if (!fs.existsSync(CONFIG.configFilePath)) {\n            throw new Error('Could not find config file ' + CONFIG.configFilePath);\n        }\n        const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, 'utf8'));\n        const options = config['options'];\n        if (null == options) {\n            throw new Error('Could not find options in ' + CONFIG.configFilePath);\n        }\n        const deployment = options['deployment'];\n        if (null == deployment) {\n            throw new Error('Could not find options/deployment in ' + CONFIG.configFilePath);\n        }\n        const sourceTargetMapping = deployment['sourceTargetMapping'];\n        if (null == sourceTargetMapping) {\n            throw new Error(\n                'Could not find options/deployment/sourceTargetMapping in ' + CONFIG.configFilePath\n            );\n        }\n        const sourceTargetMappingKeys = Object.keys(sourceTargetMapping);\n        if (null == sourceTargetMappingKeys || 1 != sourceTargetMappingKeys.length) {\n            throw new Error(\n                'Got unexpected number of keys in options/deployment/sourceTargetMapping in ' +\n                    CONFIG.configFilePath +\n                    '. Expected is only one entry'\n            );\n        }\n\n        const marketList = config['marketList'];\n        if (null == marketList) {\n            throw new Error('Could not find marketList in ' + CONFIG.configFilePath);\n        }\n        const deploymentSource = marketList[sourceTargetMappingKeys[0]];\n        if (null == deploymentSource) {\n            throw new Error(\n                'Could not find marketList/ ' +\n                    deploymentSourceKeys[0] +\n                    ' in ' +\n                    CONFIG.configFilePath\n            );\n        }\n        const deploymentSourceKeys = Object.keys(deploymentSource);\n        if (\n            null == deploymentSourceKeys ||\n            (1 != deploymentSourceKeys.length && 2 != deploymentSourceKeys.length)\n        ) {\n            throw new Error(\n                'Got unexpected number of keys in marketList/' +\n                    deploymentSource +\n                    ' in ' +\n                    CONFIG.configFilePath +\n                    '. Expected is one entry, or two in case there is a description entry.'\n            );\n        }\n        let sourceBU = null;\n        if ('description' != deploymentSourceKeys[0]) {\n            sourceBU = deploymentSourceKeys[0];\n        } else {\n            sourceBU = deploymentSourceKeys[1];\n        }\n\n        Log.debug('BU to retrieve is: ' + sourceBU);\n        return sourceBU;\n    }\n\n    /**\n     * Retrieve components into a clean retrieve folder.\n     * The retrieve folder is deleted before retrieving to make\n     * sure we have only components that really exist in the BU.\n     * TODO: replace execCommand with call to required mcdev\n     * @param {string} sourceBU specific subfolder for downloads\n     * @param {string} [retrieveFolder] place where mcdev will download to\n     * @returns {void}\n     */\n    static retrieveComponents(sourceBU, retrieveFolder) {\n        if (retrieveFolder) {\n            const retrievePath = path.join('/tmp', retrieveFolder, sourceBU);\n            let retrievePathFixed = retrievePath;\n            if (retrievePath.endsWith('/') || retrievePath.endsWith('\\\\')) {\n                retrievePathFixed = retrievePath.substring(0, retrievePath.length - 1);\n            }\n            Log.info('Delete retrieve folder ' + retrievePathFixed);\n            fs.rmSync(retrievePathFixed, { recursive: true, force: true });\n        }\n        // TODO: should use the retrieve logic from mcdev's retrieveChangelog.js instead\n        Util.execCommand(\n            'Retrieve components from ' + sourceBU,\n            'cd /tmp && ' + CONFIG.mcdev + ' retrieve ' + sourceBU + ' --skipInteraction',\n            'Completed retrieving components'\n        );\n    }\n}\n\n/**\n * handles creating the metadata json that we store for copado after retrieving it\n */\nclass Metadata {\n    /**\n     * After components have been retrieved,\n     * find all retrieved components and build a json containing as much\n     * metadata as possible.\n     * @param {string} retrieveFolder path where downloaded files are\n     * @param {string} sourceBU subfolder for BU\n     * @param {string} metadataFilePath filename & path to where we store the final json for copado\n     * @returns {void}\n     */\n    static createMetadataFile(retrieveFolder, sourceBU, metadataFilePath) {\n        const retrievePath = path.join('/tmp', retrieveFolder, sourceBU);\n        let retrievePathFixed = retrievePath;\n        if (retrievePath.endsWith('/') || retrievePath.endsWith('\\\\')) {\n            retrievePathFixed = retrievePath.substring(0, retrievePath.length - 1);\n        }\n        /**\n         * @type {MetadataItem}\n         */\n        const metadataJson = [];\n        Metadata._buildMetadataJson(retrievePathFixed, sourceBU, metadataJson);\n        const metadataString = JSON.stringify(metadataJson);\n        // Log.debug('Metadata JSON is: ' + metadataString);\n        fs.writeFileSync(metadataFilePath, metadataString);\n    }\n\n    /**\n     * After components have been retrieved,\n     * find all retrieved components and build a json containing as much\n     * metadata as possible.\n     * @private\n     * @param {string} retrieveFolder path where downloaded files are\n     * @param {string} sourceBU subfolder for BU\n     * @param {MetadataItem[]} metadataJson reference to array that we want to pass to copado\n     * @returns {void}\n     */\n    static _buildMetadataJson(retrieveFolder, sourceBU, metadataJson) {\n        // Handle files within the current directory\n        const filesAndFolders = fs\n            .readdirSync(retrieveFolder)\n            .map((entry) => path.join(retrieveFolder, entry));\n        filesAndFolders.forEach((filePath) => {\n            if (fs.statSync(filePath).isFile()) {\n                const dirName = path.dirname(filePath);\n                const componentType = path.basename(dirName);\n\n                let componentJson;\n                switch (componentType) {\n                    case 'automation':\n                        Log.debug('Handle component ' + filePath + ' with type ' + componentType);\n                        componentJson = Metadata._buildAutomationMetadataJson(filePath, 'add');\n                        break;\n                    case 'dataExtension':\n                        Log.debug('Handle component ' + filePath + ' with type ' + componentType);\n                        componentJson = Metadata._buildDataExtensionMetadataJson(filePath, 'add');\n                        break;\n                    default:\n                        throw new Error(\n                            'Component ' +\n                                filePath +\n                                ' with type ' +\n                                componentType +\n                                ' is not supported'\n                        );\n                }\n\n                // Log.debug('Metadata JSON for component ' + filePath + ' is: ' + JSON.stringify(componentJson));\n                metadataJson.push(componentJson);\n            }\n        });\n\n        // Get folders within the current directory\n        filesAndFolders.forEach((folderPath) => {\n            if (fs.statSync(folderPath).isDirectory()) {\n                Metadata._buildMetadataJson(folderPath, sourceBU, metadataJson);\n            }\n        });\n    }\n\n    /**\n     * Build the metadata JSON for a automation component\n     * @private\n     * @param {string} filePath path to json\n     * @param {string} [action] pass in value do govern what to do\n     * @returns {MetadataItem} one table row\n     */\n    static _buildAutomationMetadataJson(filePath, action) {\n        // Load the file\n        const parsed = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n\n        const metadata = {};\n        metadata['n'] = parsed['name'] ? parsed['name'] : parsed['key'];\n        metadata['k'] = parsed['key'];\n        metadata['t'] = 'automation';\n        // metadata['cd'] = parsed[''];\n        // metadata['cb'] = parsed[''];\n        // metadata['ld'] = parsed[''];\n        // metadata['lb'] = parsed[''];\n\n        if (action) {\n            metadata.a = action;\n        }\n\n        return metadata;\n    }\n\n    /**\n     * Build the metadata JSON for a data extension component\n     * @private\n     * @param {string} filePath path to json\n     * @param {string} [action] pass in value do govern what to do\n     * @returns {MetadataItem} one table row\n     */\n    static _buildDataExtensionMetadataJson(filePath, action) {\n        // Load the file\n        const parsed = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n\n        const metadata = {};\n        metadata['n'] = parsed['Name'] ? parsed['Name'] : parsed['CustomerKey'];\n        metadata['k'] = parsed['CustomerKey'];\n        metadata['t'] = 'dataExtension';\n        metadata['cd'] = parsed['CreatedDate'];\n        // metadata['cb'] = parsed[''];\n        // metadata['ld'] = parsed[''];\n        // metadata['lb'] = parsed[''];\n\n        if (action) {\n            metadata.a = action;\n        }\n\n        return metadata;\n    }\n}\n\n/**\n * methods to handle interaction with the copado platform\n */\nclass Copado {\n    /**\n     * Finally, attach the resulting metadata JSON.\n     * @param {string} metadataFilePath where we stored the temporary json file\n     * @returns {void}\n     */\n    static attachJson(metadataFilePath) {\n        Util.execCommand(\n            'Attach JSON ' + metadataFilePath,\n            'cd /tmp && copado --uploadfile \"' +\n                metadataFilePath +\n                '\" --parentid \"' +\n                CONFIG.envId +\n                '\"',\n            'Completed attaching JSON'\n        );\n    }\n\n    /**\n     * Checks out the source repository.\n     * if a feature branch is available creates\n     * the feature branch based on the main branch.\n     * @param {string} mainBranch ?\n     * @param {string} featureBranch can be null/undefined\n     * @returns {void}\n     */\n    static checkoutSrc(mainBranch, featureBranch) {\n        Util.execCommand(\n            'Cloning and checking out the main branch ' + mainBranch,\n            'cd /tmp && copado-git-get \"' + mainBranch + '\"',\n            'Completed cloning/checking out main branch'\n        );\n        if (featureBranch) {\n            Util.execCommand(\n                'Creating resp. checking out the feature branch ' + featureBranch,\n                'cd /tmp && copado-git-get --create \"' + featureBranch + '\"',\n                'Completed creating/checking out feature branch'\n            );\n        }\n    }\n    /**\n     * Checks out the source repository and branch\n     * @param {string} fromCommit commit id to merge\n     * @param {string} toBranch branch name to merge into\n     * @returns {void}\n     */\n    static checkoutSrcDeploy(fromCommit, toBranch) {\n        // First make sure that the from branch is available\n        Util.execCommand(\n            'Cloning resp. checking out the repository commit/branch ' + fromCommit,\n            'cd /tmp && copado-git-get -d . ' + fromCommit,\n            'Completed cloning commit/branch'\n        );\n\n        // Now checkout the target branch.\n        // That branch/commit that contains changed files should be checked out.\n        // When working with PRs, this is the target branch, after the source branch\n        // has been merged into this branch. So basically the version range to deploy\n        // is HEAD^..HEAD.\n        Util.execCommand(\n            'Cloning resp. checking out the repository branch ' + toBranch,\n            'cd /tmp && copado-git-get -d . ' + toBranch,\n            'Completed cloning branch'\n        );\n    }\n    /**\n     * Merge from branch into target branch\n     * @param {string} fromCommit commit id to merge\n     * @returns {void}\n     */\n    static merge(fromCommit) {\n        // Merge and commit changes.\n        Util.execCommand(\n            'Merge commit ' + fromCommit,\n            'cd /tmp && git merge \"' + fromCommit + '\"',\n            'Completed merging commit'\n        );\n    }\n\n    /**\n     * After components have been retrieved,\n     * adds selected components to the Git history.\n     * @param {string} retrieveFolder path from mcdev config\n     * @param {string} sourceBU bu name for source\n     * @param {MetadataItem[]} metadataJson list of items to be added\n     * @returns {void}\n     */\n    static addSelectedComponents(retrieveFolder, sourceBU, metadataJson) {\n        // Iterate all metadata components selected by user to commit\n        const retrieveFolderSeparator = retrieveFolder.endsWith('/') ? '' : '/';\n\n        metadataJson.forEach((component) => {\n            const name = component['n'];\n            const type = component['t'];\n            const actions = component['a'];\n            Log.debug(\n                'For component with name ' + name + ' and type ' + type + ', run actions ' + actions\n            );\n\n            let key = null;\n            // Add all components\n            if (component['k']) {\n                key = component['k'];\n            }\n            // Add selected components\n            else if (component['j']) {\n                const componentJson = JSON.parse(component['j']);\n                if (componentJson['key']) {\n                    key = componentJson['key'];\n                }\n            }\n            if (!key) {\n                throw 'Could not find key for component with name ' + name + ' and type ' + type;\n            }\n            Log.debug('For component with name ' + name + ', key is ' + key);\n\n            if (actions.includes('add')) {\n                // The file name seems to use always the key.\n                // TODO: check if the path is correctly created, also because the type is directly used twice.\n                const componentPath = `${retrieveFolder}${retrieveFolderSeparator}${sourceBU}/${type}/${key}.${type}-meta.json`;\n                Log.debug(\n                    'For component with name ' + name + ', retrieve path is ' + componentPath\n                );\n\n                if (fs.existsSync(`/tmp/${componentPath}`)) {\n                    // Add this component to the Git index.\n                    Util.execCommand(\n                        'Add ' + componentPath,\n                        'cd /tmp && git add \"' + componentPath + '\"',\n                        'Completed adding component'\n                    );\n                } else {\n                    Log.warn(\n                        'For component with name ' +\n                            name +\n                            ', could not find retrieved component file ' +\n                            componentPath\n                    );\n                }\n            }\n        });\n    }\n\n    /**\n     * Commits and pushes after adding selected components\n     * @param {string} mainBranch\n     * @param {string} featureBranch can be null/undefined\n     * @returns {void}\n     */\n    static commitAndPush(mainBranch, featureBranch) {\n        // If the following command returns some output,\n        // git commit must be executed. Otherwise there\n        // are no differences between the components retrieved\n        // from the org and selected by the user\n        // and what is already in Git, so commit and push\n        // can be skipped.\n        const branch = featureBranch ? featureBranch : mainBranch;\n        const stdout = execSync('cd /tmp && git diff --staged --name-only');\n        Log.debug('Git diff ended with the result: >' + stdout + '<');\n        if (stdout && 0 < stdout.length) {\n            Util.execCommand(\n                'Commit',\n                'cd /tmp && git commit -m \"' + CONFIG.commitMessage + '\"',\n                'Completed committing'\n            );\n            const ec = Util.execCommandReturnStatus(\n                'Push branch ' + branch,\n                'cd /tmp && git push origin \"' + branch + '\" --atomic',\n                'Completed pushing branch'\n            );\n            if (0 != ec) {\n                throw (\n                    'Could not push changes to feature branch ' +\n                    branch +\n                    '. Exit code is ' +\n                    ec +\n                    '. Please check logs for further details.'\n                );\n            }\n        } else {\n            Log.info(\n                'Nothing to commit as all selected components have the same content as already exists in Git.'\n            );\n            Util.execCommand(\n                'Nothing to Commit.',\n                'copado -p \"Nothing to commit\" -r \"Nothing to Commit as all selected components have the same content as already exists in Git.\"',\n                'Completed committing'\n            );\n        }\n    }\n}\n\nLog.info('Commit.js started');\nLog.debug('');\nLog.debug('Parameters');\nLog.debug('==========');\nLog.debug('');\nLog.debug(`mainBranch               = ${CONFIG.mainBranch}`);\nLog.debug(`featurebranch            = ${CONFIG.featureBranch}`);\nLog.debug(`metadataFile             = ${CONFIG.metadataFile}`);\nLog.debug(`commitMessage            = ${CONFIG.commitMessage}`);\nLog.debug('');\nLog.debug(`mcdevVersion             = ${CONFIG.mcdevVersion}`);\nLog.debug(`credentialName           = ${CONFIG.credentialName}`);\n// Log.debug(`clientId                 = ${clientId}`);\n// Log.debug(`clientSecret             = ${clientSecret}`);\n// Log.debug(`tenant                   = ${tenant}`);\n\nLog.info('');\nLog.info('Clone repository');\nLog.info('================');\nLog.info('');\nCopado.checkoutSrc(CONFIG.mainBranch, CONFIG.featureBranch);\n\nLog.info('');\nLog.info('Preparing');\nLog.info('=========');\nLog.info('');\nUtil.provideMCDevTools();\n\nLog.info('');\nLog.info('Initialize project');\nLog.info('==================');\nLog.info('');\nUtil.initProject();\n\nLog.info('');\nLog.info('Determine retrieve folder');\nLog.info('=========================');\nLog.info('');\nconst retrieveFolder = Retrieve.getRetrieveFolder();\n\nLog.info('');\nLog.info('Get source BU');\nLog.info('=============');\nLog.info('');\nconst sourceBU = Retrieve.getSourceBU();\n\nLog.info('');\nLog.info('Retrieve components');\nLog.info('===================');\nLog.info('');\nRetrieve.retrieveComponents(sourceBU);\n\nlet metadataJson;\nif (!CONFIG.metadataFile) {\n    Log.info('');\n    Log.info('Add all components to the metadata JSON');\n    Log.info('=======================================');\n    Log.info('');\n    const retrievePath = path.join('/tmp', retrieveFolder, sourceBU);\n    let retrievePathFixed = retrievePath;\n    if (retrievePath.endsWith('/') || retrievePath.endsWith('\\\\')) {\n        retrievePathFixed = retrievePath.substring(0, retrievePath.length - 1);\n    }\n    metadataJson = [];\n    Metadata._buildMetadataJson(retrievePathFixed, sourceBU, metadataJson);\n} else {\n    Log.info('');\n    Log.info(`Add selected components defined in ${CONFIG.metadataFile} to metadata JSON`);\n    Log.info('====================================================================');\n    Log.info('');\n\n    Util.execCommand(\n        `Download ${CONFIG.metadataFile}.`,\n        `copado --downloadfiles \"${CONFIG.metadataFile}\"`,\n        'Completed download'\n    );\n\n    const metadata = fs.readFileSync(CONFIG.metadataFileName, 'utf8');\n    metadataJson = JSON.parse(metadata);\n}\n\nLog.info('');\nLog.info('Add components in metadata JSON to Git history');\nLog.info('==============================================');\nLog.info('');\nCopado.addSelectedComponents(retrieveFolder, sourceBU, metadataJson);\n\nLog.info('');\nLog.info('Commit and push');\nLog.info('===============');\nLog.info('');\nCopado.commitAndPush(CONFIG.mainBranch, CONFIG.featureBranch);\nLog.info('');\nLog.info('Finished');\nLog.info('========');\nLog.info('');\nLog.info('Commit.js done');",
          "copado__Timeout__c": 5,
          "copado__Type__c": "Custom",
          "copado__Worker_Size__c": "S",
          "CreatedDate": "2021-09-02T08:52:28.000+0000",
          "Id": "a1t09000000YHwxAAG",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-21T10:05:42.000+0000",
          "LastReferencedDate": "2022-01-21T10:05:42.000+0000",
          "LastViewedDate": "2022-01-21T10:05:42.000+0000",
          "Name": "Marketing Cloud Commit",
          "SystemModstamp": "2022-01-21T10:05:42.000+0000"
        },
        {
          "attributes": {
            "type": "copado__Function__c",
            "url": "/services/data/v54.0/sobjects/copado__Function__c/a1t09000000YIy4AAG"
          },
          "copado__API_Name__c": "MC_Promote",
          "copado__Image_Name__c": "us.gcr.io/copado/copado-function-core:v1",
          "copado__Options__c": "[ ]",
          "copado__Parameters__c": "[ {\n  \"required\" : true,\n  \"name\" : \"git_json\",\n  \"defaultValue\" : \"{$Context.Repository.Credential}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"user_stories\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.userStoryBranches}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"promotion\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.promotionBranchName}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"target_branch\",\n  \"defaultValue\" : \"{$Context.JobExecution__r.DataJson.destinationBranchName}\"\n}, {\n  \"required\" : false,\n  \"name\" : \"tag\",\n  \"defaultValue\" : \"{$Job.ExecutionParent.Release__r.Version__c}\"\n}, {\n  \"required\" : true,\n  \"name\" : \"merge_strategy\",\n  \"defaultValue\" : \"theirs\"\n} ]",
          "copado__Script__c": "git_depth=${git_depth:-100}  # set a default git depth of 100 commits\nmerge_strategy=${merge_strategy-theirs} # set default merge strategy to ours (only if unset)\nif [ -n \"$merge_strategy\" ]; then merge_strategy_option=(-X \"$merge_strategy\"); else merge_strategy_option=(); fi\n\necho \"promotion branch: $promotion\"\necho \"merge strategy: $merge_strategy\"\necho \"user stories: $user_stories\"\necho \"git_depth: $git_depth\"\n\ncopado --progress \"fetching $target_branch\"\ncopado-git-get --depth \"$git_depth\" \"$target_branch\"\ncopado-git-get --depth \"$git_depth\" --create \"$promotion\"\nbranches=$(echo \"$user_stories\" | jq -c -r '.[]')\nfor user_story in ${branches[@]}; do\n    echo \"merging $user_story\"\n    copado-git-get --depth \"$git_depth\" \"$user_story\"\n    git checkout \"$promotion\"\n    git merge \"${merge_strategy_option[@]}\" -m \"auto resolved $user_story win over $promotion\" \"$user_story\"\ndone\n\ncopado --progress \"pushing $promotion $tag\"\n\nif [ -n \"$tag\" ]; then\n    git tag \"$tag\"\n    git push --atomic origin \"$promotion\" \"$tag\"\nelse\n    echo \"not tag specified\"\n    git push origin \"$promotion\"\nfi",
          "copado__Timeout__c": 5,
          "copado__Type__c": "Custom",
          "copado__Worker_Size__c": "S",
          "CreatedDate": "2021-09-09T11:43:25.000+0000",
          "Id": "a1t09000000YIy4AAG",
          "IsDeleted": false,
          "LastModifiedDate": "2022-01-11T08:40:58.000+0000",
          "LastReferencedDate": "2022-01-11T08:40:58.000+0000",
          "LastViewedDate": "2022-01-11T08:40:58.000+0000",
          "Name": "Marketing Cloud Promote",
          "SystemModstamp": "2022-01-11T08:40:58.000+0000"
        }
      ],
      "ObjectType": "copado__Function__c"
    }
  ],
  "blobsByUID": {}
}